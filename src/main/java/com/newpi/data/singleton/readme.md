### 单例模式
> 确保整个系统中只能存在一个实例

单例模式写法：
1. 构造方法私有
2. 提供一个公有静态方法，获取instance实例

#### 单例模式的几种写法
1. 饿汉式单例: Singleton01，类加载到内存后，只初始化一个实例，jvm保证`线程安全`，简单使用，推荐使用。其存在的缺点是，
`不具备懒加载特性`，不管用或者不用，都会初始化。**简单，推荐使用**
2. 懒汉式单例：Singleton02,实现了懒加载特性但是却带来了线程安全的问题
3. 懒汉式+synchronized单例：Singleton03，懒汉式带来了线程安全的问题，但是可以通过加锁的方式来解决。虽然解决了线程安全的问题，
但是带来了效率的问题，尤其是在大量并发访问的情况下。
4. 懒汉式+synchronized单例改进版：Singleton04，试图通过缩小同步代码块的方式来提升效率，但是线程访问不安全
5. 双重检查锁单例：Singleton05: 双重检查锁方式，实现了懒加载的特性，同时也是线程安全的单例写法，访问效率优于Singleton03的访问效率。**曾经被认为最完美的单例写法**。
6. 静态内部类单例：Singleton06，jvm 保证单例，加载外部类的时候不会加载内部类，实现懒加载特性。**完美**
7. 枚举方式：Singleton07,不仅可以解决线程同步，还能防止反序列化[`枚举类不存在构造方法，所以没办法反序列化`]。**最完美**

``注意：在使用加锁方式实现单例时，还需要加上volatile，防止编译时指令重排``

#### 破坏单例和防止破坏单例的方式
1. 破坏单例的手段：
+ 反射：反射更改构造函数的访问特性，即可实现
+ 序列化和反序列化：先将单例对象序列化，然后反序列化即可生成新的对象
+ clone: 如果实现了Cloneable接口，clone也能破坏单例的特性
2. 防止破坏单例的方式：
+ 反射方式：在私有构造函数中抛出异常，抑制私有构造函数的执行
```java
 private Singleton01(){
        if (INSTANCE != null) {
            throw new RuntimeException("unsupported operation!");
        }
    }
```
+ 序列化反序列化方式：添加readResolve方法
```java
private Object readResolve() {
        return INSTANCE;
    }
```
+ clone方式：重写clone方法，在clone方法中直接返回单例对象
```java
 @Override
    public Singleton clone() throws CloneNotSupportedException {
        return INSTANCE;
    }
```
#### 总结
综上所述，在生产环境中用到单例模式时，可使用的单例模式有饿汉式单例， 懒汉式+synchronized单例，双重检查锁单例，静态内部类单例和枚举单例，
推荐使用饿汉式单例（简单），双重检查锁、静态内部类和枚举单例。另外，在实现这些单例的时候，尽量考虑单例保护，使其不被破解。